# CASL II FAQ
## 1. よくある間違い

- 全角の空白が混ざっている
- `GR0` をアドレス修飾に用いている
- アドレスを指定すべきところに，レジスタを指定している

### 1.1 全角空白が混ざっている

見た目では何も間違っていないのにもかかわらず，下のように casl2 でアセンブルするとエラーが出た場合，プログラムのファイルに全角の空白が混ざっていないかチェックしてみてください．

```
3: Syntax error
```

### 1.2 GR0 をインデックスレジスタとして用いている

`GR0` はインデックスレジスタとして用いることはできません．したがって，

```
LD  GR1,LABEL,GR0
```

とすると，エラーになります．

### 1.3 アドレスを指定すべきところにレジスタを指定している

例えば，ST 命令は

```
ST  GR,adr[,XR]
```

です．したがって，`GR1` から `GR2` にデータを転送しようとして，

```
ST GR1,GR2
```

とすることはできません．このように書くと，casl2 で以下のようなエラーが出ます．

```
4: Undefined symbol "GR2"
```

上の `GR2` の部分は，本来，ラベル（もしくはアドレス）が入る所です． そのため，casl2 は `GR2` というラベルを探しますが，みつからないため「`GR2` というシンボルが定義されていない」という旨のエラーメッセージを出力します． エラーメッセージの内容と実際のエラーの内容が少し違っているので，知らないと間違いに気づきにくいかもしれません．

なお，`GR1` から `GR2` にデータを転送したい場合は，`LD` 命令などを用いてください．

## 2. Caps Lock

CASL II のプログラムを書くと，どうしても大文字での入力が多くなります．

`Shift` キーを押しても良いですが，普段あまり出番のない `Caps Lock` を有効利用してください．
（ヒントというほどのことではありませんが）

ただし，CMC の共用の PC を使うときは，ログオフする前に `Caps Lock` をオフにしておいてください．

## 3. リテラルについて

リテラルは教科書の 60 ページにこっそり書いてある機能ですが，便利なので多用する人も多いでしょう． しかし，その実装がどうなっているかにまで気を配っている人は少ないのではないでしょうか．

下のプログラムを見てみましょう．

```
CASL LISTING ex1.cas
   2 0000 1210		LAD	GR1,0
   2      0000
   3 0002 1220		LAD	GR2,888
   3      0378
   4 0004 2412	LOOP1	ADDA	GR1,GR2
   5 0005 2120		SUBA	GR2,=1
   5      001e
   6 0007 6300		JZE	NEXT
   6      000b
   7 0009 6400		JUMP	LOOP1
   7      0004
   8 000b 1110	NEXT	ST	GR1,RES1
   8      001b
   9 000d 1210		LAD	GR1,0
   9      0000
  10 000f 1220		LAD	GR2,777
  10      0309
  11 0011 2412	LOOP2	ADDA	GR1,GR2
  12 0012 2120		SUBA	GR2,=1
  12      001e
  13 0014 6300		JZE	NEXT
  13      000b
  14 0016 6400		JUMP	LOOP2
  14      0011
  15 0018 1110	FIN	ST	GR1,RES2
  15      001c
  16 001a 8100		RET	
  17 001b 0000	RES1	DS	1
  18 001c 0000	RES2	DS	1
  19 001d 0001		END	
  19      0001

DEFINED SYMBOLS 
	1:	0000	PRGEX1 
	4:	0004	LOOP1
	8:	000b	NEXT
	11:	0011	LOOP2
	15:	0018	FIN
	17:	001b	RES1
	18:	001c	RES2
```

このプログラムでは，5 行目と 12 行目に`=1` というリテラルを定義しています． よく見ると，

```
   5 0005 2120		SUBA	GR2,=1
   5      001e
```

この命令では，`#001e` 番地を参照しているだけです． `#001e` 番地には何があるかというと・・・

```
  18 001c 0000	RES2	DS	1
  19 001d 0001		END	
  19      0001                  ←ここ！
```

なんだか，変な感じになっています．確かに 1 という値は `001e` 番地に入っているようですが・・・

私の casl2 の実装では，リテラルを１回限り利用するラベルの無い `DC` 命令と見なしてアセンブルします． ですので，リテラルを多用したプログラムでは，`END` の後にずらずらと `DC` 命令の残骸が残っていくことになります．

普段，皆さんが CASL II/COMET II を利用する分には何ら気にしなくてもいいはずですが，ひょっとしたらこれを意識しなければならない時がくるかもしれません． そのときのために，このコラムを残しておきます．

CASL II の仕様を作成した人としてはこれで便利になると思って採用したのだと思いますが，実装を作る側では結構大変な処理でした．

## COMET II ブレイクポイントの使い方

CASL II/COMET II のデバッグは目に見える情報が大すぎて意味がわからない，という人が多いのではないでしょうか．また，ループが大きくなると `s` を連打するのがしんどい！という人もいそうですね．

今日は効率的なデバッグのための「ブレイクポイント」についての話です．

まず，以下のようなプログラムがあるとします．

```
PRGEX1	START
	LAD	GR1,0
	LAD	GR2,888
LOOP1	ADDA	GR1,GR2
	SUBA	GR2,=1
	JZE	NEXT
	JUMP	LOOP1
NEXT	ST	GR1,RES1
	LAD	GR1,0
	LAD	GR2,777
LOOP2	ADDA	GR1,GR2
	SUBA	GR2,=1
	JZE	NEXT
	JUMP	LOOP2
FIN	ST	GR1,RES2
	RET
RES1	DS	1
RES2	DS	1
	END
```

非常に単純なプログラムですが，まず，1 から 888 までの和を計算し，次に 1 から 777 までの和を計算します．`LOOP1` と `LOOP2` の部分でそれぞれ計算をしています．

実は，このプログラムにはバグがあります．それがどこにあるのかを探したいとします．

まずは，アセンブルしてみます．

```
$ casl2 ex1.cas
$
```

問題なくアセンブルされました．文法的には正しいということです．

では，実行してみましょう．

```
bash-2.05b$ ./comet2 ex1.com
This is COMET II, version 1.0.1.
Copyright (c) 2001, Osamu Mizuno.
All rights reserved.
Reading object from ex1.com...done.

PR  #0000 [ LAD      GR1, #0000      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> r
```

しーん・・・．固まってしまいました．実行時エラーですね．たぶん．

じゃあ，`s` で実行するか．

```
bash-2.05b$ ./comet2 ex1.com
This is COMET II, version 1.0.1.
Copyright (c) 2001, Osamu Mizuno.
All rights reserved.
Reading object from ex1.com...done.

PR  #0000 [ LAD      GR1, #0000      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0002 [ LAD      GR2, #0378      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0004 [ ADDA     GR1, GR2        ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0378(   888)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0005 [ SUBA     GR2, #001e      ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0378(   888)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0007 [ JZE      #000b           ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0377(   887)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0009 [ JUMP     #0004           ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0377(   887)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0004 [ ADDA     GR1, GR2        ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0377(   887)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s
```

・・・，これは `GR2` が 0 になるまで実行を続けるので，`s` の連打では指が痛くなります． まずは，ラベル `NEXT` あたりまで到達したかどうかが知りたいだけなのですが・・・

そんなときに使えるのが， `b` コマンドです． `b` コマンドは，プログラムの実行を一旦停止するポイント（ブレイクポイント）を設定する comet2 シミュレータのコマンドです． 使い方は，

```
comet> b 番地
```

とするだけです． しかし，ここで注意して欲しいのは，番地にはラベルが使えないということ． 今の場合だと，`NEXT` というラベルが示す番地が必要になります．

番地を知るためには，casl2 でのアセンブル時に出力される詳細な結果を見る必要があります． 

```
CASL LISTING 
   2 0000 1210		LAD	GR1,0
   2      0000
   3 0002 1220		LAD	GR2,888
   3      0378
   4 0004 2412	LOOP1	ADDA	GR1,GR2
   5 0005 2120		SUBA	GR2,=1
   5      001e
   6 0007 6300		JZE	NEXT
   6      000b
   7 0009 6400		JUMP	LOOP1
   7      0004
   8 000b 1110	NEXT	ST	GR1,RES1
   8      001b
   9 000d 1210		LAD	GR1,0
   9      0000
  10 000f 1220		LAD	GR2,777
  10      0309
  11 0011 2412	LOOP2	ADDA	GR1,GR2
  12 0012 2120		SUBA	GR2,=1
  12      001e
  13 0014 6300		JZE	NEXT
  13      000b
  14 0016 6400		JUMP	LOOP2
  14      0011
  15 0018 1110	FIN	ST	GR1,RES2
  15      001c
  16 001a 8100		RET	
  17 001b 0000	RES1	DS	1
  18 001c 0000	RES2	DS	1
  19 001d 0001		END	
  19      0001

DEFINED SYMBOLS
	1:	0000	PRGEX1 
	4:	0004	LOOP1
	8:	000b	NEXT
	11:	0011	LOOP2
	15:	0018	FIN
	17:	001b	RES1
	18:	001c	RES2
	19:	001e	=1
$
```

最後の部分がまさにそれ．ラベル `NEXT` は `000b` 番地だとわかります．では，comet2 に戻りましょう．

```
PR  #0000 [ LAD      GR1, #0000      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet2>
```

まず，ブレイクポイントをセットします．番地は 16 進数だったので`#000b` と指定します．

```
comet2> b #000b
```

そこで実行．

```
comet2> r
Breakpoint 0, #000b

PR  #000b [ ST       GR1, #001b      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #05dc(  1500)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet>
```

`PR` が`#000b` となり，現在の番地が `000b` であることが確認できます． そして，`r` コマンドを実行したのに実行が一時停止し，コマンド受け状態に戻ったことがわかります．

もうひとつ，ブレイクポイントを設定してみましょう． ブレイクポイントはいくつでも設定でき，設定した順に 0,1 という番号が振られていきます．

今度は `FIN` にセットします．`FIN` は`#0018` 番地でしたので，次のように設定し，`r` で実行します．

```
comet2> b #0018
comet2> r
Breakpoint 0, #000b

PR  #000b [ ST       GR1, #001b      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #9cad(-25427)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> 
```

・・・あれ？おかしいですね．また`#000b` 番地に戻ってきています．もともとこのプログラムは `NEXT` は１回しか通らないはずなのに．

と，言うことは `NEXT` へジャンプするあたりが怪しいです． そう思ってリストを眺めると・・・

```
  11 0011 2412	LOOP2	ADDA	GR1,GR2
  12 0012 2120		SUBA	GR2,=1
  12      001e
  13 0014 6300		JZE	NEXT
  13      000b
  14 0016 6400		JUMP	LOOP2
  14      0011
```

ここの `JZE` ですね．本来 `FIN` へ行くはずなのに，`NEXT` へ飛んでいる．上から Copy & Paste するときに変更し忘れたのが原因です．

このように，バグを取り除く際にブレイクポイントを活用すれば，非常に効率的な調査が可能になります．是非，活用してみてください．
