# CASL II
1. よくある間違い
  1. 全角空白が混ざっている

  見た目では何も間違っていないのにもかかわらず、casl2でアセンブルするとエラーが出た場合、プログラムのファイルに全角の空白が混ざっていないかチェックしてみてください。

  2. `GR0`をインデックスレジスタとして用いている

  `GR0`はインデックスレジスタとして用いることはできません。したがって、

  ```
  LD  GR1,LABEL,GR0
  ```
  とすると、エラーになります。

  3. アドレスを指定すべきところにレジスタを指定している

  例えば、`ST`命令は
  ```
  ST  GR,adr[,XR]
  ```
  です。したがって、`GR1`から`GR2`にデータを転送しようとして、

  ```
  ST GR1,GR2
  ```
  とすることはできません。このように書くと、casl2で以下のようなエラーが出ます。

  ```
  4: Undefined symbol "GR2"
  ```
  上の`GR2`の部分は、本来、ラベル（もしくはアドレス）が入る所です。 そのため、casl2は`GR2`というラベルを探しますが、みつからないため「`GR2`というシンボルが定義されていない」という旨のエラーメッセージを出力します。 エラーメッセージの内容と実際のエラーの内容が少し違っているので、知らないと間違いに気づきにくいかもしれません。

  `GR1`から`GR2`にデータを転送したい場合は、`LD`命令などを用いてください。

2. リテラルについて

  CASL IIにはリテラルという機能が定義されています．これは，オペランドに直接値を指定する機能です．
  なお，言語処理プログラミングでは，リテラルの利用は推奨しません．ここでは，リテラルの実装について述べておきます．

  下のプログラムを見てみましょう。
```
CASL LISTING 
   2 0000 1210		LAD	GR1,0
   2      0000
   3 0002 1220		LAD	GR2,888
   3      0378
   4 0004 2412	LOOP1	ADDA	GR1,GR2
   5 0005 2120		SUBA	GR2,=1
   5      001e
   6 0007 6300		JZE	NEXT
   6      000b
   7 0009 6400		JUMP	LOOP1
   7      0004
   8 000b 1110	NEXT	ST	GR1,RES1
   8      001b
   9 000d 1210		LAD	GR1,0
   9      0000
  10 000f 1220		LAD	GR2,777
  10      0309
  11 0011 2412	LOOP2	ADDA	GR1,GR2
  12 0012 2120		SUBA	GR2,=1
  12      001e
  13 0014 6300		JZE	NEXT
  13      000b
  14 0016 6400		JUMP	LOOP2
  14      0011
  15 0018 1110	FIN	ST	GR1,RES2
  15      001c
  16 001a 8100		RET	
  17 001b 0000	RES1	DS	1
  18 001c 0000	RES2	DS	1
  19 001d 0001		END	
  19      0001

DEFINED SYMBOLS 
	1:	0000	PRGEX1 
	4:	0004	LOOP1
	8:	000b	NEXT
	11:	0011	LOOP2
	15:	0018	FIN
	17:	001b	RES1
	18:	001c	RES2
 	19:	001e	=1
```
このプログラムでは、5行目と12行目に`=1`というリテラルを定義しています。 よく見ると、
```
   5 0005 2120		SUBA	GR2,=1
   5      001e
```
この命令では、#001e番地を参照しているだけです。 #001e番地には何があるかというと・・・
```
  18 001c 0000	RES2	DS	1
  19 001d 0001		END	
  19      0001                  ←ここ！
```
なんだか、変な感じになっています。確かに1という値は001e番地に入っているようですが・・・

このcasl2の実装では、リテラルを1回限り利用するラベルの無い`DC`命令と見なしてアセンブルします。 ですので、リテラルを多用したプログラムでは、`END`の後にずらずらと`DC`命令の残骸が残っていくことになります。

普段、皆さんがCASL II/COMET IIを利用する分には何ら気にしなくてもいいはずですが、ひょっとしたらこれを意識しなければならない時がくるかもしれません。 そのときのために、このコラムを残しておきます。

CASL IIの仕様を作成した人としてはこれで便利になると思って採用したのだと思いますが、実装を作る側では結構大変な処理でした。

# COMET II

ブレイクポイントの使い方
演習で使っているCASL II/COMET IIの製作者である水野先生のコラムより

CASL II/COMET IIのデバッグは目に見える情報が大すぎて意味がわからない、という人が多いのではないでしょうか。また、ループが大きくなると"s"を連打するのがしんどい！という人もいそうですね。

今日は効率的なデバッグのための「ブレイクポイント」についての話です。

まず、以下のようなプログラムがあるとします。

PRGEX1	START
	LAD	GR1,0
	LAD	GR2,888
LOOP1	ADDA	GR1,GR2
	SUBA	GR2,=1
	JZE	NEXT
	JUMP	LOOP1
NEXT	ST	GR1,RES1
	LAD	GR1,0
	LAD	GR2,777
LOOP2	ADDA	GR1,GR2
	SUBA	GR2,=1
	JZE	NEXT
	JUMP	LOOP2
FIN	ST	GR1,RES2
	RET
RES1	DS	1
RES2	DS	1
	END
非常に単純なプログラムですが、まず、1から888までの和を計算し、次に1から777までの和を計算します。LOOP1とLOOP2の部分でそれぞれ計算をしています。

実は、このプログラムにはバグがあります。それがどこにあるのかを探したいとします。

まずは、アセンブルしてみます。

$ casl2 ex1.cas
$
問題なくアセンブルされました。文法的には正しいということです。

では、実行してみましょう。

bash-2.05b$ ./comet2 ex1.com
This is COMET II, version 1.0.1.
Copyright (c) 2001, Osamu Mizuno.
All rights reserved.
Reading object from ex1.com...done.

PR  #0000 [ LAD      GR1, #0000      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> r
しーん・・・。固まってしまいました。実行時エラーですね。たぶん。

じゃあ、sで実行するか。

bash-2.05b$ ./comet2 ex1.com
This is COMET II, version 1.0.1.
Copyright (c) 2001, Osamu Mizuno.
All rights reserved.
Reading object from ex1.com...done.

PR  #0000 [ LAD      GR1, #0000      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0002 [ LAD      GR2, #0378      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0004 [ ADDA     GR1, GR2        ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0378(   888)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0005 [ SUBA     GR2, #001e      ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0378(   888)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0007 [ JZE      #000b           ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0377(   887)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0009 [ JUMP     #0004           ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0377(   887)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s

PR  #0004 [ ADDA     GR1, GR2        ]
SP  #ff00(  -256)  FR  000  (     0)
GR0 #0000(     0)  GR1 #0378(   888)  GR2 #0377(   887)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> s
・・・、これはGR2が0になるまで実行を続けるので、sの連打では指が痛くなります。 まずは、ラベルNEXTあたりまで到達したかどうかが知りたいだけなのですが・・・

そんなときに使えるのが、 b コマンドです。 bコマンドは、プログラムの実行を一旦停止するポイント（ブレイクポイント）を設定するcomet2シミュレータのコマンドです。 使い方は、

comet> b 番地
とするだけです。 しかし、ここで注意して欲しいのは、番地にはラベルが使えないということ。 今の場合だと、NEXTというラベルが示す番地が必要になります。

番地を知るためには、casl2でのアセンブル時に -a オプションをつける必要があります。 やってみましょう。

$ casl2 -a ex1.cas
CASL LISTING ex1.cas
   2 0000 1210		LAD	GR1,0
   2      0000
   3 0002 1220		LAD	GR2,888
   3      0378
   4 0004 2412	LOOP1	ADDA	GR1,GR2
   5 0005 2120		SUBA	GR2,=1
   5      001e
   6 0007 6300		JZE	NEXT
   6      000b
   7 0009 6400		JUMP	LOOP1
   7      0004
   8 000b 1110	NEXT	ST	GR1,RES1
   8      001b
   9 000d 1210		LAD	GR1,0
   9      0000
  10 000f 1220		LAD	GR2,777
  10      0309
  11 0011 2412	LOOP2	ADDA	GR1,GR2
  12 0012 2120		SUBA	GR2,=1
  12      001e
  13 0014 6300		JZE	NEXT
  13      000b
  14 0016 6400		JUMP	LOOP2
  14      0011
  15 0018 1110	FIN	ST	GR1,RES2
  15      001c
  16 001a 8100		RET	
  17 001b 0000	RES1	DS	1
  18 001c 0000	RES2	DS	1
  19 001d 0001		END	
  19      0001

DEFINED SYMBOLS
	ex1.cas:1:	0000	PRGEX1 
	ex1.cas:4:	0004	LOOP1
	ex1.cas:8:	000b	NEXT
	ex1.cas:11:	0011	LOOP2
	ex1.cas:15:	0018	FIN
	ex1.cas:17:	001b	RES1
	ex1.cas:18:	001c	RES2
	ex1.cas:19:	001e	=1
$
最後の部分がまさにそれ。ラベルNEXTは000b番地だとわかります。では、comet2に戻りましょう。

$ comet2 ex1.com
This is COMET II, version 1.0.1.
Copyright (c) 2001, Osamu Mizuno.
All rights reserved.
Reading object from ex1.com...done.

PR  #0000 [ LAD      GR1, #0000      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #0000(     0)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet>
まず、ブレイクポイントをセットします。番地は16進数だったので#000bと指定します。

comet> b #000b
そこで実行。

comet> r
Breakpoint 0, #000b

PR  #000b [ ST       GR1, #001b      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #05dc(  1500)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet>
PRが#000bとなり、現在の番地が000bであることが確認できます。 そして、rコマンドを実行したのに実行が一時停止し、コマンド受け状態に戻ったことがわかります。

もうひとつ、ブレイクポイントを設定してみましょう。 ブレイクポイントはいくつでも設定することができ、設定した順に0,1という番号が振られていきます。

今度はFINにセットします。FINは#0018番地でしたので、次のように設定し、rで実行します。

comet> b #0018
comet> r
Breakpoint 0, #000b

PR  #000b [ ST       GR1, #001b      ]
SP  #ff00(  -256)  FR  001  (     1)
GR0 #0000(     0)  GR1 #9cad(-25427)  GR2 #0000(     0)  GR3 #0000(     0)
GR4 #0000(     0)  GR5 #0000(     0)  GR6 #0000(     0)  GR7 #0000(     0)
comet> 
・・・あれ？おかしいですね。また#000b番地に戻ってきています。もともとこのプログラムはNEXTは１回しか通らないはずなのに。

と、言うことはNEXTへジャンプするあたりが怪しいです。 そう思ってリストを眺めると・・・

  11 0011 2412	LOOP2	ADDA	GR1,GR2
  12 0012 2120		SUBA	GR2,=1
  12      001e
  13 0014 6300		JZE	NEXT
  13      000b
  14 0016 6400		JUMP	LOOP2
  14      0011
ここのJZEですね。本来FINへ行くはずなのに、NEXTへ飛んでいる。上からCopy & Pasteするときに変更し忘れたのが原因です。

このように、バグを取り除く際にブレイクポイントを活用すれば、非常に効率的な調査が可能になります。是非、活用してみてください。