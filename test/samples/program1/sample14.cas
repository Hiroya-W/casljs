%%sample14	START
	LAD	gr0,0
	CALL	L0001
	CALL	FLUSH
	RET
; program sample14;
; var
$com	DC	0
; com : char;
$y	DC	0
$x	DC	0
; x , y : integer;
$endflag
	DC	0
; endflag : boolean;
L0001
; begin
	LAD	gr1,	L0002
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( '   *** Calculator -- h for help ***' );
	LAD	gr1,	0
	ST	gr1,	$x
; x := 0;
	LD	gr1,gr0
	ST	gr1,	$endflag
; endflag := false;
L0003
	LD	gr1,	$endflag
	LAD	gr2,1
	SUBA	gr2,gr1
	LD	gr1,gr2
	CPA	gr1,gr0
	JZE	L0004
; while not endflag do
; begin
	LAD	gr1,	L0005
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( ' Please input command :' );
	LAD	gr1,	$com
	CALL	READCHAR
	LAD	gr1,	$y
	CALL	READINT
	CALL	READLINE
; readln ( com , y );
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	99
	POP	gr2
	CPA	gr2,gr1
	JZE	L0008
	LAD	gr1,0
	JUMP	L0009
L0008
	LAD	gr1,1
L0009
	PUSH	0,gr1
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	67
	POP	gr2
	CPA	gr2,gr1
	JZE	L0010
	LAD	gr1,0
	JUMP	L0011
L0010
	LAD	gr1,1
L0011
	POP	gr2
	OR	gr1,gr2
	CPA	gr1,gr0
	JZE	L0006
; if ( com = 'c' ) or ( com = 'C' ) then
; begin
	LD	gr1,	$y
	ST	gr1,	$x
; x := y;
; end
	JUMP	L0007
L0006
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	43
	POP	gr2
	CPA	gr2,gr1
	JZE	L0014
	LAD	gr1,0
	JUMP	L0015
L0014
	LAD	gr1,1
L0015
	CPA	gr1,gr0
	JZE	L0012
; else if com = '+' then
; begin
	LD	gr1,	$x
	PUSH	0,gr1
	LD	gr1,	$y
	POP	gr2
	ADDA	gr1,gr2
	JOV	EOVF
	ST	gr1,	$x
; x := x + y;
; end
	JUMP	L0013
L0012
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	45
	POP	gr2
	CPA	gr2,gr1
	JZE	L0018
	LAD	gr1,0
	JUMP	L0019
L0018
	LAD	gr1,1
L0019
	CPA	gr1,gr0
	JZE	L0016
; else if com = '-' then
; begin
	LD	gr1,	$x
	PUSH	0,gr1
	LD	gr1,	$y
	POP	gr2
	SUBA	gr2,gr1
	JOV	EOVF
	LD	gr1,gr2
	ST	gr1,	$x
; x := x - y;
; end
	JUMP	L0017
L0016
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	42
	POP	gr2
	CPA	gr2,gr1
	JZE	L0022
	LAD	gr1,0
	JUMP	L0023
L0022
	LAD	gr1,1
L0023
	CPA	gr1,gr0
	JZE	L0020
; else if com = '*' then
; begin
	LD	gr1,	$x
	PUSH	0,gr1
	LD	gr1,	$y
	POP	gr2
	MULA	gr1,gr2
	JOV	EOVF
	ST	gr1,	$x
; x := x * y;
; end
	JUMP	L0021
L0020
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	47
	POP	gr2
	CPA	gr2,gr1
	JZE	L0026
	LAD	gr1,0
	JUMP	L0027
L0026
	LAD	gr1,1
L0027
	CPA	gr1,gr0
	JZE	L0024
; else if com = '/' then
; begin
	LD	gr1,	$x
	PUSH	0,gr1
	LD	gr1,	$y
	POP	gr2
	DIVA	gr2,gr1
	JOV	E0DIV
	LD	gr1,gr2
	ST	gr1,	$x
; x := x div y;
; end
	JUMP	L0025
L0024
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	111
	POP	gr2
	CPA	gr2,gr1
	JZE	L0030
	LAD	gr1,0
	JUMP	L0031
L0030
	LAD	gr1,1
L0031
	PUSH	0,gr1
	LD	gr1,	$com
	PUSH	0,gr1
	LAD	gr1,	79
	POP	gr2
	CPA	gr2,gr1
	JZE	L0032
	LAD	gr1,0
	JUMP	L0033
L0032
	LAD	gr1,1
L0033
	POP	gr2
	OR	gr1,gr2
	CPA	gr1,gr0
	JZE	L0028
; else if ( com = 'o' ) or ( com = 'O' ) then
; begin
	LAD	gr1,1
	ST	gr1,	$endflag
; endflag := true
; end
	JUMP	L0029
L0028
; else
; begin
	CALL	WRITELINE
; writeln;
	LAD	gr1,	L0034
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( 'Calculator Usage:' );
	LAD	gr1,	L0035
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( '  c number : clear & set it' );
	LAD	gr1,	L0036
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( '  + number : add it' );
	LAD	gr1,	L0037
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( '  - number : subtract it' );
	LAD	gr1,	L0038
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( '  * number : multiply it' );
	LAD	gr1,	L0039
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( '  / number : divide it' );
	LAD	gr1,	L0040
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
; writeln ( '  o        : off(terminate execution)' );
	CALL	WRITELINE
; writeln
L0029
L0025
L0021
L0017
L0013
L0007
; end;
	LD	gr1,	$endflag
	CPA	gr1,gr0
	JZE	L0041
; if endflag then
	LAD	gr1,	L0043
	LD	gr2,gr0
	CALL	WRITESTR
	LD	gr1,	$x
	LD	gr2,gr0
	CALL	WRITEINT
	CALL	WRITELINE
; writeln ( 'Final Result =' , x )
; else
	JUMP	L0042
L0041
	LAD	gr1,	L0044
	LD	gr2,gr0
	CALL	WRITESTR
	LD	gr1,	$x
	LD	gr2,gr0
	CALL	WRITEINT
	CALL	WRITELINE
L0042
; writeln ( 'Temporary Result =' , x )
	JUMP	L0003
L0004
; end
	RET
L0002	DC	'   *** Calculator -- h for help ***'
L0005	DC	' Please input command :'
L0034	DC	'Calculator Usage:'
L0035	DC	'  c number : clear & set it'
L0036	DC	'  + number : add it'
L0037	DC	'  - number : subtract it'
L0038	DC	'  * number : multiply it'
L0039	DC	'  / number : divide it'
L0040	DC	'  o        : off(terminate execution)'
L0043	DC	'Final Result ='
L0044	DC	'Temporary Result ='
; ------------------------
; Utility functions
; ------------------------
EOVF	CALL	WRITELINE
	LAD	gr1,EOVF1
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
	SVC	1	;  overflow error stop
EOVF1	DC	'***** Run-Time Error : Overflow *****'
E0DIV	JNZ	EOVF
	CALL	WRITELINE
	LAD	gr1,E0DIV1
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
	SVC	2 	;  0-divide error stop
E0DIV1	DC	'***** Run-Time Error : Zero-Divide *****'
EROV	CALL	WRITELINE
	LAD	gr1,EROV1
	LD	gr2,gr0
	CALL	WRITESTR
	CALL	WRITELINE
	SVC	3	;  range-over error stop
EROV1	DC	'***** Run-Time Error : Range-Over in Array Index *****'
; gr1の値（文字）をgr2のけた数で出力する．
; gr2が0なら必要最小限の桁数で出力する
WRITECHAR
	RPUSH
	LD	gr6,SPACE
	LD	gr7,	OBUFSIZE
WC1	SUBA	gr2,ONE		; while(--c > 0) {
	JZE	WC2
	JMI	WC2
	ST	gr6,OBUF,gr7	;  *p++ = ' ';
	CALL	BOVFCHECK
	JUMP	WC1 		; }
WC2	ST	gr1,OBUF,gr7	; *p++ = gr1;
	CALL	BOVFCHECK
	ST	gr7, OBUFSIZE
	RPOP
	RET
; gr1が指す文字列をgr2のけた数で出力する．
; gr2が0なら必要最小限の桁数で出力する
WRITESTR
	RPUSH
	LD	gr6,gr1		; p = gr1;
WS1	LD	gr4,0,gr6	; while(*p != 0) {
	JZE	WS2
	ADDA	gr6,ONE		;  p++;
	SUBA	gr2,ONE		;  c--;
	JUMP	WS1		; }
WS2	LD	gr7,OBUFSIZE	; q = OBUFSIZE;
	LD	gr5,SPACE
WS3	SUBA	gr2,ONE		; while(--c >= 0) {
	JMI	WS4
	ST	gr5,OBUF,gr7	;  *q++ = ' ';
	CALL	BOVFCHECK
	JUMP	WS3		; }
WS4	LD	gr4,0,gr1	; while(*gr1 != 0) {
	JZE	WS5
	ST	gr4,OBUF,gr7	;  *q++ = *gr1++;
	ADDA	gr1,ONE
	CALL	BOVFCHECK
	JUMP	WS4		; }
WS5	ST	gr7,OBUFSIZE	; OBUFSIZE = q;
	RPOP
	RET
BOVFCHECK
	ADDA	gr7,ONE
	CPA	gr7, BOVFLEVEL
	JMI	BOVF1
	CALL	WRITELINE
	LD	gr7,OBUFSIZE
BOVF1	RET
BOVFLEVEL
	DC	256
; gr1の値（整数）をgr2のけた数で出力する．
; gr2が0なら必要最小限の桁数で出力する
WRITEINT
	RPUSH
	LD	gr7,gr0  	; flag = 0;
	CPA	gr1,gr0 	; if(gr1>=0) goto WI1;
	JPL	WI1
	JZE	WI1
	LD	gr4,gr0  	; gr1= - gr1;
	SUBA	gr4,gr1
	CPA	gr4,gr1
	JZE	WI6
	LD	gr1,gr4
	LD	gr7,ONE  	; flag = 1;
WI1	LD	gr6,SIX  	; p = INTBUF+6;
	ST	gr0,INTBUF,gr6	; *p = 0;
	SUBA	gr6,ONE  	; p--;
	CPA	gr1,gr0  	; if(gr1 == 0)
	JNZ	WI2
	LD	gr4,ZERO 	;  *p = '0';
	ST	gr4,INTBUF,gr6
	JUMP	WI5 		; }
				; else {
WI2	CPA	gr1,gr0 	;  while(gr1 != 0) {
	JZE	WI3
	LD	gr5,gr1 	;   gr5 = gr1 - (gr1 / 10) * 10;
	DIVA	gr1,TEN 	;   gr1 /= 10;
	LD	gr4,gr1
	MULA	gr4,TEN
	SUBA	gr5,gr4
	ADDA	gr5,ZERO 	;   gr5 += '0';
	ST	gr5,INTBUF,gr6 	;   *p = gr5;
	SUBA	gr6,ONE 	;   p--;
	JUMP	WI2 		;  }
WI3	CPA	gr7,gr0 	;  if(flag != 0) {
	JZE	WI4
	LD	gr4,MINUS 	;   *p = '-';
	ST	gr4,INTBUF,gr6
	JUMP	WI5 		;  }
WI4	ADDA	gr6,ONE 	;  else p++;
				; }
WI5	LAD	gr1,INTBUF,gr6 	; gr1 = p;
	CALL	WRITESTR 	; WRITESTR();
	RPOP
	RET
WI6	LAD	gr1,MMINT
	CALL	WRITESTR 	; WRITESTR();
	RPOP
	RET
MMINT	DC	'-32768'
; gr1の値（真理値）が0なら'FALSE'を
; 0以外なら'TRUE'をgr2のけた数で出力する．
; gr2が0なら必要最小限の桁数で出力する
WRITEBOOL
	RPUSH
	CPA	gr1,gr0 	; if(gr1 != 0)
	JZE	WB1
	LAD	gr1,WBTRUE 	;  gr1 = TRUE;
	JUMP	WB2
				; else
WB1	LAD	gr1,WBFALSE 	;  gr1 = FALSE;
WB2	CALL	WRITESTR 	; WRITESTR();
	RPOP
	RET
WBTRUE	DC	'TRUE'
WBFALSE	DC	'FALSE'
; 改行を出力する
WRITELINE
	RPUSH
	LD	gr7,OBUFSIZE
	LD	gr6,NEWLINE
	ST	gr6,OBUF,gr7
	ADDA	gr7,ONE
	ST	gr7,OBUFSIZE
	OUT	OBUF,OBUFSIZE
	ST	gr0,OBUFSIZE
	RPOP
	RET
FLUSH	RPUSH
	LD	gr7,OBUFSIZE
	JZE	FL1
	CALL	WRITELINE
FL1	RPOP
	RET
; gr1が指す番地に文字一つを読み込む
READCHAR
	RPUSH
	LD	gr5,RPBBUF 	; if(RPBBUF != 0) {
	JZE	RC0
	ST	gr5,0,gr1 	;  *gr1 = RPBBUF;
	ST	gr0,RPBBUF 	;  RPBBUF = 0
	JUMP	RC3 		;  return; }
RC0	LD	gr7,INP 	; inp = INP;
	LD	gr6,IBUFSIZE 	; if(IBUFSIZE == 0) {
	JNZ	RC1
	IN	IBUF,IBUFSIZE 	;  IN();
	LD	gr7,gr0 	;  inp = 0;
				; }
RC1	CPA	gr7,IBUFSIZE 	; if(inp == IBUFSIZE) {
	JNZ	RC2
	LD	gr5,NEWLINE 	;  *gr1 = '\n';
	ST	gr5,0,gr1
	ST	gr0,IBUFSIZE 	;  IBUFSIZE = INP = 0;
	ST	gr0,INP
	JUMP	RC3 		; }
				; else {
RC2	LD	gr5,IBUF,gr7 	;  *gr1 = *inp++;
	ADDA	gr7,ONE
	ST	gr5,0,gr1
	ST	gr7,INP 	;  INP = inp;
				; }
RC3	RPOP
	RET
; gr1が指す番地に整数値一つを読み込む
READINT	RPUSH
				; do {
RI1	CALL	READCHAR 	;  ch = READCHAR();
	LD	gr7,0,gr1
	CPA	gr7,SPACE 	; } while(ch==' ' || ch=='\t' || ch=='\n');
	JZE	RI1
	CPA	gr7,TAB
	JZE	RI1
	CPA	gr7,NEWLINE
	JZE	RI1
	LD 	gr5,ONE 	; flag = 1
	CPA	gr7,MINUS 	; if(ch == '-') {
	JNZ	RI4
	LD	gr5,gr0 	;  flag = 0;
	CALL	READCHAR 	;  ch = READCHAR();
	LD	gr7,0,gr1	; }
RI4	LD	gr6,gr0 	; v = 0;
RI2	CPA	gr7,ZERO 	; while('0' <= ch && ch <= '9') {
	JMI	RI3
	CPA	gr7,NINE
	JPL	RI3
	MULA	gr6,TEN 	;  v = v*10+ch-'0';
	ADDA	gr6,gr7
	SUBA	gr6,ZERO
	CALL	READCHAR 	;  ch = READSCHAR();
	LD	gr7,0,gr1
	JUMP	RI2 		; }
RI3	ST	gr7,RPBBUF 	; ReadPushBack();
	ST	gr6,0,gr1 	; *gr1 = v;
	CPA	gr5,gr0 	; if(flag == 0) {
	JNZ	RI5
	SUBA	gr5,gr6 	;  *gr1 = -v;
	ST	gr5,0,gr1
				; }
RI5	RPOP
	RET
; 入力を改行コードまで（改行コードも含む）読み飛ばす
READLINE
	ST	gr0,IBUFSIZE
	ST	gr0,INP
	ST	gr0,RPBBUF
	RET
ONE	DC 	1
SIX	DC 	6
TEN	DC 	10
SPACE	DC 	#0020 	; ' '
MINUS	DC 	#002D 	; '-'
TAB	DC	#0009 	; '\t'
ZERO	DC	#0030 	; '0'
NINE	DC	#0039 	; '9'
NEWLINE	DC 	#000A 	; '\n'
INTBUF	DS 	8
OBUFSIZE
	DC	0
IBUFSIZE
	DC	0
INP	DC	0
OBUF	DS	257
IBUF	DS	257
RPBBUF	DC	0
	END
